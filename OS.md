#   OS

##  常见问题与回答

1.  进程与线程？
回答：  
-   进程是操作系统资源分配的基本单位；线程是CPU调度的最小单位；

-   一个进程中可以有多个线程，一个线程只能存在于一个进程里。

-   进程在执行时拥有独立的内存单元，而同一进程内的线程则会共享进程的内存。

-   线程共享代码段（代码、常量）、数据段（全局变量、静态变量）、扩展段（堆）；但是线程拥有自己的栈段！（线程有自己的局部变量和临时变量）      

-   创建、撤销进程的开销远远大于创建、撤销线程的开销。  ：涉及分配、回收系统资源
-   进程切换的开销也远大于线程切换。    ：旧进程环境保存与新进程环境设置；线程只需保存、设置少量寄存器值

-   线程的通信十分方便，进程间通信麻烦；

-   进程编程调试简单可靠性高，开销大；线程编程编程复杂，开销小。

-   进程之间不会相互影响；而一个线程挂掉会导致整个进程挂掉。


1.1    协程？

协程可以通过yield（取其“让步”之义而非“出产”）来调用其它协程，接下来的每次协程被调用时，从协程上次yield返回的位置接着执行，通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的

在协程之间的切换不需要涉及任何系统调用或任何阻塞调用



2.  生产者消费者模型？信号量？互斥量？
回答：
-   生产者消费者模型：
    使用一个缓存来保存任务。开启一个或是多个线程来生产任务（生产者），然后再开启一个或多个线程从缓存中取出任务来执行（消费者）。
    这样做的优点是：任务的生成和处理分开生产者只负责生产任务然后送到缓存；而消费者只负责从缓存取出任务并执行。可以根据实际情况来调整生产者与消费者的数量关系。

-   信号量：


-   互斥量：




3.  死锁？产生条件？避免死锁？
回答：
-   死锁：
    所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
    
    产生原因：
    1.  资源竞争
    2.  进程间推进顺序非法

-   产生的必要条件：
    1.  互斥条件：          一个资源每次只能被一个进程使用；
    2.  请求与保持条件：    一个进程因请求资源而阻塞时，对已获得的资源保持不释放；    
    3.  不剥夺条件：        进程已获得的资源，在未使用完之前，不能强行剥夺；
    4.  循环等待条件：      若干进程之间形成一种首尾相接的循环等待资源关系。

-   解决死锁：

    破坏上述四个条件之一。

    1.  资源一次性分配：一次性分配所有资源，这样就不会再有请求了；
    2.  只要有一个资源得不到分配，也不给该进程分配其余资源；
    3.  可剥夺资源：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；
    4.  资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反


-   避免死锁：
1.  最具代表性算法————银行家算法

P - 进程的集合
Mp - 进程p的最大的请求数目
Cp - 进程p当前被分配的资源
A - 当前可用的资源

    ```
    while (P != ∅) {
        found = FALSE;
        foreach (p ∈ P) {
            if (Mp − Cp ≤ A) {
                /* p可以獲得他所需的資源。假設他得到資源後執行；執行終止，並釋放所擁有的資源。*/
                A = A + Cp ;
                P = P − {p};
                found = TRUE;
            }
        }
        if (! found) return FAIL;
    }
    return OK;
    ```


2.  设置时限。



4.  锁？
回答：
-   互斥锁 mutex ：    用于保证任何时刻都只能由一个线程访问某对象；获取锁失败时，线程进入睡眠，等待锁释放时被唤醒；

-   读写锁 rwlock ：   分为读锁和写锁，处于读模式时，可允许多个线程同时读；但是同一时刻只能有一个线程获取写锁，其他获取写锁的线程会睡眠，直到写锁释放时被唤醒。
    写锁会阻塞其他的读写锁，即写的时候不能读，写锁会优先与读锁。

-   自旋锁 spinlock ： 任何时刻只有一个线程可以访问对象，但是获取锁失败时不进入睡眠，而是在原地自旋，直到锁被释放。
    节省了唤醒线程的消耗，适用于加锁时间非常短的情况。          节省资源的消耗是以消耗CPU资源为代价的。

-   RCU read-copy-update ：  读取数据并复制，对副本进行修改操作；修改完之后再把老数据更新为新数据。
    不需要获得锁，不会导致锁的竞争，不用考虑死锁问题。代价是对于写操作的成本很大。


5.  并发与并行？
回答：
-   并发：  指的是两个程序在宏观上看起来像是同时运行，其实是交织进行，程序在各自的时间片段内运行，可以提高效率；

-   并行：  严格意义上的同时运行。


6.  内存泄露与内存溢出区别？
回答：
-   内存溢出：  申请空间时空间不够用。     所需的内存空间超过了系统分配的值。
    原因：  内存加载的数据量过于庞大；
            集合类中有对对象的引用，使用完未清空，使不能回收；
            代码存在死循环或是循环产生了太多重复的对象实体；
            使用的软件由BUG；
            启动参数内存值设置太小。

-   内存泄漏：  已经申请的空间没有被释放，导致该空间再也无法被重复利用。
    1.  堆内存泄露：malloc/new 等申请的内存分配在堆上，用完之后却没有free/delete；
    2.  系统资源泄露：程序使用了系统分配的资源后却没有使用相应的函数释放；
    3.  没有将基类的析构函数定义为虚函数：基类指针指向了派生类对象，如果基类的析构函数不是virtual，那么就不能调用到子类的析构函数，子类的空间就无法正确释放。


7.  多线程同步

借助互斥量


8.  静态变量什么时候初始化？
回答：
    静态变量存储在虚拟地址空间的数据段和BSS段。
    C语言在代码执行之前初始化，属于编译期初始化；C++规定全局或局部静态对象当且仅当首次调用时进行构造。

9.  虚拟地址空间？
回答：
    [点击这里](https://blog.csdn.net/qq_33883085/article/details/88430087)

10. 用户态、内核态区别？
回答：
    用户态和内核态有不同的运行级别；
    用户态低级权限，内核态高级权限；
    运行在用户态的程序不能直接访问操作系统内核数据结构和程序；

    内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。


11. 乐观锁？悲观锁？


